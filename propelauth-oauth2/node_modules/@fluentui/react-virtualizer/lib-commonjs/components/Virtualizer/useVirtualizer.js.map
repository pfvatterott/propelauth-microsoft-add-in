{"version":3,"sources":["useVirtualizer.ts"],"sourcesContent":["import type { ReactNode } from 'react';\nimport type { VirtualizerProps, VirtualizerState } from './Virtualizer.types';\n\nimport { useEffect, useRef, useCallback, useReducer, useImperativeHandle, useState } from 'react';\nimport { useIntersectionObserver } from '../../hooks/useIntersectionObserver';\nimport { flushSync } from 'react-dom';\nimport { useVirtualizerContextState_unstable } from '../../Utilities';\nimport { slot, useTimeout } from '@fluentui/react-utilities';\n\nexport function useVirtualizer_unstable(props: VirtualizerProps): VirtualizerState {\n  'use no memo';\n\n  const {\n    itemSize,\n    numItems,\n    virtualizerLength,\n    children: renderChild,\n    getItemSize,\n    bufferItems = Math.round(virtualizerLength / 4.0),\n    bufferSize = Math.floor(bufferItems / 2.0) * itemSize,\n    scrollViewRef,\n    axis = 'vertical',\n    reversed = false,\n    virtualizerContext,\n    onRenderedFlaggedIndex,\n    imperativeVirtualizerRef,\n  } = props;\n\n  /* The context is optional, it's useful for injecting additional index logic, or performing uniform state updates*/\n  const _virtualizerContext = useVirtualizerContextState_unstable(virtualizerContext);\n\n  // We use this ref as a constant source to access the virtualizer's state imperatively\n  const actualIndexRef = useRef<number>(_virtualizerContext.contextIndex);\n  if (actualIndexRef.current !== _virtualizerContext.contextIndex) {\n    actualIndexRef.current = _virtualizerContext.contextIndex;\n  }\n  const flaggedIndex = useRef<number | null>(null);\n\n  const actualIndex = _virtualizerContext.contextIndex;\n  const setActualIndex = _virtualizerContext.setContextIndex;\n\n  // Store ref to before padding element\n  const beforeElementRef = useRef<Element | null>(null);\n\n  // Store ref to before padding element\n  const afterElementRef = useRef<Element | null>(null);\n\n  // We need to store an array to track dynamic sizes, we can use this to incrementally update changes\n  const childSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n\n  /* We keep track of the progressive sizing/placement down the list,\n  this helps us skip re-calculations unless children/size changes */\n  const childProgressiveSizes = useRef<number[]>(new Array<number>(getItemSize ? numItems : 0));\n\n  // The internal tracking REF for child array (updates often).\n  const childArray = useRef<ReactNode[]>(new Array(virtualizerLength));\n\n  // We want to be methodical about updating the render with child reference array\n  const forceUpdate = useReducer(() => ({}), {})[1];\n\n  const horizontal = axis === 'horizontal';\n\n  const populateSizeArrays = () => {\n    if (!getItemSize) {\n      // Static sizes, never mind!\n      return;\n    }\n\n    if (numItems !== childSizes.current.length) {\n      childSizes.current = new Array<number>(numItems);\n    }\n\n    if (numItems !== childProgressiveSizes.current.length) {\n      childProgressiveSizes.current = new Array<number>(numItems);\n    }\n\n    for (let index = 0; index < numItems; index++) {\n      childSizes.current[index] = getItemSize(index);\n      if (index === 0) {\n        childProgressiveSizes.current[index] = childSizes.current[index];\n      } else {\n        childProgressiveSizes.current[index] = childProgressiveSizes.current[index - 1] + childSizes.current[index];\n      }\n    }\n  };\n\n  const [isScrolling, setIsScrolling] = useState<boolean>(false);\n  const [setScrollTimer, clearScrollTimer] = useTimeout();\n  const scrollCounter = useRef<number>(0);\n\n  const initializeScrollingTimer = useCallback(() => {\n    /*\n     * This can be considered the 'velocity' required to start 'isScrolling'\n     * INIT_SCROLL_FLAG_REQ: Number of renders required to activate isScrolling\n     * INIT_SCROLL_FLAG_DELAY: Amount of time (ms) before current number of renders is reset\n     *  - Maybe we should let users customize these in the future.\n     */\n    const INIT_SCROLL_FLAG_REQ = 10;\n    const INIT_SCROLL_FLAG_DELAY = 100;\n\n    scrollCounter.current++;\n    if (scrollCounter.current >= INIT_SCROLL_FLAG_REQ) {\n      setIsScrolling(true);\n    }\n    clearScrollTimer();\n    setScrollTimer(() => {\n      setIsScrolling(false);\n      scrollCounter.current = 0;\n    }, INIT_SCROLL_FLAG_DELAY);\n  }, [clearScrollTimer, setScrollTimer]);\n\n  useEffect(() => {\n    initializeScrollingTimer();\n  }, [actualIndex, initializeScrollingTimer]);\n\n  const batchUpdateNewIndex = (index: number) => {\n    // Local updates\n    updateChildRows(index);\n    updateCurrentItemSizes(index);\n\n    // Set before 'setActualIndex' call\n    // If it changes before render, or injected via context, re-render will update ref.\n    actualIndexRef.current = index;\n\n    // State setters\n    setActualIndex(index);\n  };\n\n  // Observe intersections of virtualized components\n  const { setObserverList } = useIntersectionObserver(\n    // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n    // eslint-disable-next-line no-restricted-globals\n    (entries: IntersectionObserverEntry[], observer: IntersectionObserver) => {\n      /* Sanity check - do we even need virtualization? */\n      if (virtualizerLength > numItems) {\n        if (actualIndex !== 0) {\n          batchUpdateNewIndex(0);\n        }\n        // No-op\n        return;\n      }\n\n      /* IO initiates this function when needed (bookend entering view) */\n      let measurementPos = 0;\n      let bufferCount = bufferItems;\n\n      // Grab latest entry that is intersecting\n      const latestEntry =\n        entries.length === 1\n          ? entries[0]\n          : entries\n              .sort((entry1, entry2) => entry2.time - entry1.time)\n              .find(entry => {\n                return entry.intersectionRatio > 0;\n              });\n\n      if (!latestEntry) {\n        // If we don't find an intersecting area, ignore for now.\n        return;\n      }\n\n      if (latestEntry.target === afterElementRef.current) {\n        // We need to inverse the buffer count\n        bufferCount = virtualizerLength - bufferItems;\n        measurementPos = reversed ? calculateAfter() : calculateTotalSize() - calculateAfter();\n        if (!horizontal) {\n          if (reversed) {\n            // Scrolling 'up' and hit the after element below\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n          } else if (latestEntry.boundingClientRect.top < 0) {\n            // Scrolling 'down' and hit the after element above top: 0\n            measurementPos -= latestEntry.boundingClientRect.top;\n          }\n        } else {\n          if (reversed) {\n            // Scrolling 'left' and hit the after element\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n          } else if (latestEntry.boundingClientRect.left < 0) {\n            // Scrolling 'right' and hit the after element\n            measurementPos -= latestEntry.boundingClientRect.left;\n          }\n        }\n      } else if (latestEntry.target === beforeElementRef.current) {\n        measurementPos = reversed ? calculateTotalSize() - calculateBefore() : calculateBefore();\n        if (!horizontal) {\n          if (!reversed) {\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.bottom);\n          } else if (latestEntry.boundingClientRect.top < 0) {\n            // Scrolling 'down' in reverse order and hit the before element above top: 0\n            measurementPos -= latestEntry.boundingClientRect.top;\n          }\n        } else {\n          if (!reversed) {\n            measurementPos -= Math.abs(latestEntry.boundingClientRect.right);\n          } else if (latestEntry.boundingClientRect.left < 0) {\n            // Scrolling 'left' and hit before element\n            measurementPos -= latestEntry.boundingClientRect.left;\n          }\n        }\n      }\n\n      if (reversed) {\n        // We're reversed, up is down, left is right, invert the scroll measure.\n        measurementPos = Math.max(calculateTotalSize() - Math.abs(measurementPos), 0);\n      }\n\n      // For now lets use hardcoded size to assess current element to paginate on\n      const startIndex = getIndexFromScrollPosition(measurementPos);\n      const bufferedIndex = Math.max(startIndex - bufferCount, 0);\n\n      // Safety limits\n      const maxIndex = Math.max(numItems - virtualizerLength, 0);\n      const newStartIndex = Math.min(Math.max(bufferedIndex, 0), maxIndex);\n\n      if (actualIndex !== newStartIndex) {\n        // We flush sync this and perform an immediate state update\n        flushSync(() => {\n          batchUpdateNewIndex(newStartIndex);\n        });\n      }\n    },\n    {\n      root: scrollViewRef ? scrollViewRef?.current : null,\n      rootMargin: '0px',\n      threshold: 0,\n    },\n  );\n\n  const findIndexRecursive = (scrollPos: number, lowIndex: number, highIndex: number): number => {\n    if (lowIndex > highIndex) {\n      // We shouldn't get here - but no-op the index if we do.\n      return actualIndex;\n    }\n    const midpoint = Math.floor((lowIndex + highIndex) / 2);\n    const iBefore = Math.max(midpoint - 1, 0);\n    const iAfter = Math.min(midpoint + 1, childProgressiveSizes.current.length - 1);\n    const indexValue = childProgressiveSizes.current[midpoint];\n    const afterIndexValue = childProgressiveSizes.current[iAfter];\n    const beforeIndexValue = childProgressiveSizes.current[iBefore];\n    if (scrollPos <= afterIndexValue && scrollPos >= beforeIndexValue) {\n      /* We've found our index - if we are exactly matching before/after index that's ok,\n      better to reduce checks if it's right on the boundary. */\n      return midpoint;\n    }\n\n    if (indexValue > scrollPos) {\n      return findIndexRecursive(scrollPos, lowIndex, midpoint - 1);\n    } else {\n      return findIndexRecursive(scrollPos, midpoint + 1, highIndex);\n    }\n  };\n\n  const getIndexFromSizeArray = (scrollPos: number): number => {\n    /* Quick searches our progressive height array */\n    if (\n      scrollPos === 0 ||\n      childProgressiveSizes.current.length === 0 ||\n      scrollPos <= childProgressiveSizes.current[0]\n    ) {\n      // Check start\n      return 0;\n    }\n\n    if (scrollPos >= childProgressiveSizes.current[childProgressiveSizes.current.length - 1]) {\n      // Check end\n      return childProgressiveSizes.current.length - 1;\n    }\n\n    return findIndexRecursive(scrollPos, 0, childProgressiveSizes.current.length - 1);\n  };\n\n  const getIndexFromScrollPosition = (scrollPos: number) => {\n    if (!getItemSize) {\n      return Math.round(scrollPos / itemSize);\n    }\n\n    return getIndexFromSizeArray(scrollPos);\n  };\n\n  const calculateTotalSize = useCallback(() => {\n    if (!getItemSize) {\n      return itemSize * numItems;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1];\n  }, [getItemSize, itemSize, numItems]);\n\n  const calculateBefore = useCallback(() => {\n    const currentIndex = Math.min(actualIndex, numItems - 1);\n\n    if (!getItemSize) {\n      // The missing items from before virtualization starts height\n      return currentIndex * itemSize;\n    }\n\n    if (currentIndex <= 0) {\n      return 0;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[currentIndex - 1];\n  }, [actualIndex, getItemSize, itemSize, numItems]);\n\n  const calculateAfter = useCallback(() => {\n    if (numItems === 0 || actualIndex + virtualizerLength >= numItems) {\n      return 0;\n    }\n\n    const lastItemIndex = Math.min(actualIndex + virtualizerLength, numItems);\n    if (!getItemSize) {\n      // The missing items from after virtualization ends height\n      const remainingItems = numItems - lastItemIndex;\n      return remainingItems * itemSize;\n    }\n\n    // Time for custom size calcs\n    return childProgressiveSizes.current[numItems - 1] - childProgressiveSizes.current[lastItemIndex - 1];\n  }, [actualIndex, getItemSize, itemSize, numItems, virtualizerLength]);\n\n  const updateChildRows = useCallback(\n    (newIndex: number) => {\n      if (numItems === 0) {\n        /* Nothing to virtualize */\n        return;\n      }\n\n      /*\n        We reset the array every time to ensure children are re-rendered\n        This function should only be called when update is nessecary\n       */\n      childArray.current = new Array(virtualizerLength);\n      const _actualIndex = Math.max(newIndex, 0);\n      const end = Math.min(_actualIndex + virtualizerLength, numItems);\n      for (let i = _actualIndex; i < end; i++) {\n        childArray.current[i - _actualIndex] = renderChild(i, isScrolling);\n      }\n    },\n    [isScrolling, numItems, renderChild, virtualizerLength],\n  );\n\n  const setBeforeRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || beforeElementRef.current === element) {\n        return;\n      }\n      beforeElementRef.current = element;\n      const newList = [];\n\n      newList.push(beforeElementRef.current);\n\n      if (afterElementRef.current) {\n        newList.push(afterElementRef.current);\n      }\n\n      // Ensure we update array if before element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  const setAfterRef = useCallback(\n    (element: HTMLDivElement) => {\n      if (!element || afterElementRef.current === element) {\n        return;\n      }\n      afterElementRef.current = element;\n      const newList = [];\n\n      if (beforeElementRef.current) {\n        newList.push(beforeElementRef.current);\n      }\n\n      newList.push(afterElementRef.current);\n\n      // Ensure we update array if after element changed\n      setObserverList(newList);\n    },\n    [setObserverList],\n  );\n\n  const updateCurrentItemSizes = (newIndex: number) => {\n    if (!getItemSize) {\n      // Static sizes, not required.\n      return;\n    }\n    // We should always call our size function on index change (only for the items that will be rendered)\n    // This ensures we request the latest data for incoming items in case sizing has changed.\n    const endIndex = Math.min(newIndex + virtualizerLength, numItems);\n    const startIndex = Math.max(newIndex, 0);\n\n    let didUpdate = false;\n    for (let i = startIndex; i < endIndex; i++) {\n      const newSize = getItemSize(i);\n      if (newSize !== childSizes.current[i]) {\n        childSizes.current[i] = newSize;\n        didUpdate = true;\n      }\n    }\n\n    if (didUpdate) {\n      // Update our progressive size array\n      for (let i = startIndex; i < numItems; i++) {\n        const prevSize = i > 0 ? childProgressiveSizes.current[i - 1] : 0;\n        childProgressiveSizes.current[i] = prevSize + childSizes.current[i];\n      }\n    }\n  };\n\n  // Initialize the size array before first render.\n  const hasInitialized = useRef<boolean>(false);\n  const initializeSizeArray = () => {\n    if (hasInitialized.current === false) {\n      hasInitialized.current = true;\n      populateSizeArrays();\n    }\n  };\n\n  useImperativeHandle(\n    imperativeVirtualizerRef,\n    () => {\n      return {\n        progressiveSizes: childProgressiveSizes,\n        nodeSizes: childSizes,\n        setFlaggedIndex: (index: number | null) => (flaggedIndex.current = index),\n        currentIndex: actualIndexRef,\n      };\n    },\n    [childProgressiveSizes, childSizes],\n  );\n\n  // Initialization on mount - update array index to 0 (ready state).\n  // Only fire on mount (no deps).\n  useEffect(() => {\n    if (actualIndex < 0) {\n      batchUpdateNewIndex(0);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // If the user passes in an updated renderChild function - update current children\n  useEffect(() => {\n    if (actualIndex >= 0) {\n      updateChildRows(actualIndex);\n      forceUpdate();\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [renderChild, updateChildRows]);\n\n  useEffect(() => {\n    // Ensure we repopulate if getItemSize callback changes\n    populateSizeArrays();\n\n    // We only run this effect on getItemSize change (recalc dynamic sizes)\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [getItemSize]);\n\n  // Effect to check flag index on updates\n  useEffect(() => {\n    if (!onRenderedFlaggedIndex || flaggedIndex.current === null) {\n      return;\n    }\n    if (actualIndex <= flaggedIndex.current && actualIndex + virtualizerLength >= flaggedIndex.current) {\n      onRenderedFlaggedIndex(flaggedIndex.current);\n      flaggedIndex.current = null;\n    }\n  }, [actualIndex, onRenderedFlaggedIndex, virtualizerLength]);\n\n  // Ensure we have run through and updated the whole size list array at least once.\n  initializeSizeArray();\n\n  if (getItemSize && (numItems !== childSizes.current.length || numItems !== childProgressiveSizes.current.length)) {\n    // Child length mismatch, repopulate size arrays.\n    populateSizeArrays();\n  }\n\n  // Ensure we recalc if virtualizer length changes\n  const maxCompare = Math.min(virtualizerLength, numItems);\n  if (childArray.current.length !== maxCompare && actualIndex + childArray.current.length < numItems) {\n    updateChildRows(actualIndex);\n  }\n\n  const isFullyInitialized = hasInitialized.current && actualIndex >= 0;\n  return {\n    components: {\n      before: 'div',\n      after: 'div',\n      beforeContainer: 'div',\n      afterContainer: 'div',\n    },\n    virtualizedChildren: childArray.current,\n    before: slot.always(props.before, {\n      defaultProps: {\n        ref: setBeforeRef,\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    after: slot.always(props.after, {\n      defaultProps: {\n        ref: setAfterRef,\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    beforeContainer: slot.always(props.beforeContainer, {\n      defaultProps: {\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    afterContainer: slot.always(props.afterContainer, {\n      defaultProps: {\n        role: 'none',\n      },\n      elementType: 'div',\n    }),\n    beforeBufferHeight: isFullyInitialized ? calculateBefore() : 0,\n    afterBufferHeight: isFullyInitialized ? calculateAfter() : 0,\n    totalVirtualizerHeight: isFullyInitialized ? calculateTotalSize() : virtualizerLength * itemSize,\n    virtualizerStartIndex: actualIndex,\n    axis,\n    bufferSize,\n    reversed,\n    childSizes,\n    childProgressiveSizes,\n  };\n}\n"],"names":["useVirtualizer_unstable","props","itemSize","numItems","virtualizerLength","children","renderChild","getItemSize","bufferItems","Math","round","bufferSize","floor","scrollViewRef","axis","reversed","virtualizerContext","onRenderedFlaggedIndex","imperativeVirtualizerRef","_virtualizerContext","useVirtualizerContextState_unstable","actualIndexRef","useRef","contextIndex","current","flaggedIndex","actualIndex","setActualIndex","setContextIndex","beforeElementRef","afterElementRef","childSizes","Array","childProgressiveSizes","childArray","forceUpdate","useReducer","horizontal","populateSizeArrays","length","index","isScrolling","setIsScrolling","useState","setScrollTimer","clearScrollTimer","useTimeout","scrollCounter","initializeScrollingTimer","useCallback","INIT_SCROLL_FLAG_REQ","INIT_SCROLL_FLAG_DELAY","useEffect","batchUpdateNewIndex","updateChildRows","updateCurrentItemSizes","setObserverList","useIntersectionObserver","entries","observer","measurementPos","bufferCount","latestEntry","sort","entry1","entry2","time","find","entry","intersectionRatio","target","calculateAfter","calculateTotalSize","abs","boundingClientRect","bottom","top","right","left","calculateBefore","max","startIndex","getIndexFromScrollPosition","bufferedIndex","maxIndex","newStartIndex","min","flushSync","root","rootMargin","threshold","findIndexRecursive","scrollPos","lowIndex","highIndex","midpoint","iBefore","iAfter","indexValue","afterIndexValue","beforeIndexValue","getIndexFromSizeArray","currentIndex","lastItemIndex","remainingItems","newIndex","_actualIndex","end","i","setBeforeRef","element","newList","push","setAfterRef","endIndex","didUpdate","newSize","prevSize","hasInitialized","initializeSizeArray","useImperativeHandle","progressiveSizes","nodeSizes","setFlaggedIndex","maxCompare","isFullyInitialized","components","before","after","beforeContainer","afterContainer","virtualizedChildren","slot","always","defaultProps","ref","role","elementType","beforeBufferHeight","afterBufferHeight","totalVirtualizerHeight","virtualizerStartIndex"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":"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"}