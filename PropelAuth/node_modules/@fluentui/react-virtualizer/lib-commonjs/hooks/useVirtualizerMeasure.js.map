{"version":3,"sources":["useVirtualizerMeasure.ts"],"sourcesContent":["import * as React from 'react';\nimport { VirtualizerMeasureProps } from './hooks.types';\nimport { useResizeObserverRef_unstable } from './useResizeObserverRef';\n\n/**\n * React hook that measures virtualized space based on a static size to ensure optimized virtualization length.\n */\nexport const useStaticVirtualizerMeasure = <TElement extends HTMLElement>(\n  virtualizerProps: VirtualizerMeasureProps,\n): {\n  virtualizerLength: number;\n  bufferItems: number;\n  bufferSize: number;\n  scrollRef: (instance: TElement | null) => void;\n} => {\n  const { defaultItemSize, direction = 'vertical' } = virtualizerProps;\n\n  const [state, setState] = React.useState({\n    virtualizerLength: 0,\n    bufferSize: 0,\n    bufferItems: 0,\n  });\n\n  const { virtualizerLength, bufferItems, bufferSize } = state;\n\n  const resizeCallback = React.useCallback(\n    (\n      _entries: ResizeObserverEntry[],\n      // TODO: exclude types from this lint rule: https://github.com/microsoft/fluentui/issues/31286\n      // eslint-disable-next-line no-restricted-globals\n      _observer: ResizeObserver,\n      scrollRef?: React.MutableRefObject<HTMLElement | null>,\n    ) => {\n      if (!scrollRef?.current) {\n        return;\n      }\n\n      const containerSize =\n        direction === 'vertical'\n          ? scrollRef?.current.getBoundingClientRect().height\n          : scrollRef?.current.getBoundingClientRect().width;\n\n      /*\n       * Number of items required to cover viewport.\n       */\n      const length = Math.ceil(containerSize / defaultItemSize + 1);\n\n      /*\n       * Number of items to append at each end, i.e. 'preload' each side before entering view.\n       */\n      const newBufferItems = Math.max(Math.floor(length / 4), 2);\n\n      /*\n       * This is how far we deviate into the bufferItems to detect a redraw.\n       */\n      const newBufferSize = Math.max(Math.floor((length / 8) * defaultItemSize), 1);\n\n      const totalLength = length + newBufferItems * 2 + 1;\n\n      setState({\n        virtualizerLength: totalLength,\n        bufferItems: newBufferItems,\n        bufferSize: newBufferSize,\n      });\n    },\n    [defaultItemSize, direction],\n  );\n\n  const scrollRef = useResizeObserverRef_unstable(resizeCallback);\n\n  return {\n    virtualizerLength,\n    bufferItems,\n    bufferSize,\n    scrollRef,\n  };\n};\n"],"names":["useStaticVirtualizerMeasure","virtualizerProps","defaultItemSize","direction","state","setState","React","useState","virtualizerLength","bufferSize","bufferItems","resizeCallback","useCallback","_entries","_observer","scrollRef","current","containerSize","getBoundingClientRect","height","width","length","Math","ceil","newBufferItems","max","floor","newBufferSize","totalLength","useResizeObserverRef_unstable"],"rangeMappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;","mappings":";;;;+BAOaA;;;eAAAA;;;;iEAPU;sCAEuB;AAKvC,MAAMA,8BAA8B,CACzCC;IAOA,MAAM,EAAEC,eAAe,EAAEC,YAAY,UAAU,EAAE,GAAGF;IAEpD,MAAM,CAACG,OAAOC,SAAS,GAAGC,OAAMC,QAAQ,CAAC;QACvCC,mBAAmB;QACnBC,YAAY;QACZC,aAAa;IACf;IAEA,MAAM,EAAEF,iBAAiB,EAAEE,WAAW,EAAED,UAAU,EAAE,GAAGL;IAEvD,MAAMO,iBAAiBL,OAAMM,WAAW,CACtC,CACEC,UAEA,iDAAiD;IACjDC,WACAC;QAEA,IAAI,CAACA,CAAAA,cAAAA,QAAAA,cAAAA,KAAAA,IAAAA,KAAAA,IAAAA,UAAWC,OAAO,AAAPA,GAAS;YACvB;QACF;QAEA,MAAMC,gBACJd,cAAc,aACVY,cAAAA,QAAAA,cAAAA,KAAAA,IAAAA,KAAAA,IAAAA,UAAWC,OAAO,CAACE,qBAAqB,GAAGC,MAAM,GACjDJ,cAAAA,QAAAA,cAAAA,KAAAA,IAAAA,KAAAA,IAAAA,UAAWC,OAAO,CAACE,qBAAqB,GAAGE,KAAK;QAEtD;;OAEC,GACD,MAAMC,SAASC,KAAKC,IAAI,CAACN,gBAAgBf,kBAAkB;QAE3D;;OAEC,GACD,MAAMsB,iBAAiBF,KAAKG,GAAG,CAACH,KAAKI,KAAK,CAACL,SAAS,IAAI;QAExD;;OAEC,GACD,MAAMM,gBAAgBL,KAAKG,GAAG,CAACH,KAAKI,KAAK,CAACL,SAAU,IAAKnB,kBAAkB;QAE3E,MAAM0B,cAAcP,SAASG,iBAAiB,IAAI;QAElDnB,SAAS;YACPG,mBAAmBoB;YACnBlB,aAAac;YACbf,YAAYkB;QACd;IACF,GACA;QAACzB;QAAiBC;KAAU;IAG9B,MAAMY,YAAYc,IAAAA,mDAAAA,EAA8BlB;IAEhD,OAAO;QACLH;QACAE;QACAD;QACAM;IACF;AACF"}